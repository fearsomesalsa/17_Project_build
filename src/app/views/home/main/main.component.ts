import {
  AfterViewInit,
  Component,
  ElementRef,
  OnDestroy,
  OnInit,
  TemplateRef,
  ViewChild,
} from '@angular/core';
import { CartService } from '../../../shared/services/cart.service';
import { from, map, Observable, Subject, Subscription } from 'rxjs';
import { NgbModal } from '@ng-bootstrap/ng-bootstrap';
import { PopupComponent } from '../../../shared/components/popup/popup.component';
import { environment } from '../../../../environments/environment';

// Для таких ситуаций существует один способ - объявить спец. переменную в файле через ключевое слово declare, чтобы предупредить компилятор об использовании существующей глобальной переменной на странице, тип которой м.б. любым.
// declare var bootstrap: any; // указываем тип any, т.к. мы не знаем, что будет находиться в этой библиотеке, и какой здесь можно будет задать тип.

// Когда подключили тайпинги для бутстрап
// import * as bootstrap from 'bootstrap'; // теперь ошибки не будет в new bootstrap.Modal('#myModal', {}). И можно через Ctrl нажимать на методы и свойства бутстрапа и переходить в файлы документации библиотеки + пользоваться автодополнением.

@Component({
  selector: 'app-main',
  templateUrl: './main.component.html',
  styleUrls: ['./main.component.scss'],
})
export class MainComponent implements OnInit, OnDestroy, AfterViewInit {
  // private observable: Observable<string>; // т.к. это дженерик тайп, нужно указать с каким типом будет работать этот Observable. У нас он будет работать со строками, т.к. в next() передаем значение 'hello'
  // private observable: Observable<number>; // для случая, когда next принимает count++, Observable работает с числами, изменили тип

  private subject: Subject<number>; // создадим спец. объект Subject для полхода "Hot Observable"

  // private promise: Promise<string>; // Для сравнения сделаем все то же самое на промисах.
  constructor(public cartService: CartService, private modalService: NgbModal) {
    // иницлиализируем subject
    this.subject = new Subject<number>(); // не передаем никакую функцию для инициализации
    // теперь отдельно от созания мы можем генерировать какие-то события
    let count = 0;
    const interval = setInterval(() => {
      this.subject.next(count++);
    }, 1000);
    const timeout1 = setTimeout(() => {
      this.subject.complete();
    }, 4000);
  }

  private subscription: Subscription | null = null;

  // @ViewChild('popup') // 'popup' - это название той переменной, которую мы хотим использовать
  // popup!: TemplateRef<ElementRef>; // чтобы не инициализировать сразу тут или в конструкторе, используем оператор ненулевого типа
  // !Важно! То, что мы получаем через декоратор ViewChild и получаем там ссылку, мы можем использовать ТОЛЬКО ПОСЛЕ того, как весь view будет инициализирован, т.е. после выполнения метода ngAfterViewInit()

  ngOnInit() {
    // Выведем то, что находится в файле environment.ts. Несколько вариантов импортом, мы всегда выбираем универсальный файл (без .prod)
    console.log(environment.production); // выводит false

    this.subscription = this.subject.subscribe({
      next: (param: number) => {
        console.log('subscriber 1: ', param);
      },
      error: (error: string) => {
        console.log('ERROR!!! ' + error);
      },
    });
  }

  @ViewChild(PopupComponent)
  private popupComponent!: PopupComponent; // автоматически в эту переменую попадет наш попап <app-popup>, т.е. наш компонент

  ngAfterViewInit(): void {
    // this.popupComponent.open(); // Сделаем так, чтобы попап на главной не отображался
  }

  ngOnDestroy() {
    this.subscription?.unsubscribe();
  }

  // test(popup: TemplateRef<ElementRef>) {
  // this.modalService.open(popup, {});
  test() {
    // заменим на subject
    this.subject
      .pipe(
        map((number) => {
          return 'Число: ' + number;
        })
      )
      .subscribe((param: string) => {
        // функция-колбэк будет срабатывать каждый раз, когда внутри Observable мы вызываем next(), т.е. предоставляем какое-то значение, т.е. генерируем событие. Аргумент param имеет тип string, т.к. мы знаем, что Observable возвращает строки (у нас 'hello')
        console.log('subscriber 2: ', param);
      });
  }
}

// Promise vs Observable
// Ключевое отличие в том, что промис отработал и завершил свое выполнение полностью. После того, как then выполнился промиса уже не существует, и больше мы с ним ничего не можем сделать.
// Т.е. промис подходит для какой-то одноразовой асинхронной операции.
// А Observable после всего этого не завершил свое существование и функция subscriber продолжает слушать изменения нашего Observable-объекта, пока этот Observable не завершится, либо пока мы не отпишемся от него сами.

// Одна из самых грубых ошибок при работе с Observable - работа с Observable как с промисами. Когда мы не используем систему подписок, каждый раз делая новые subscriberы.

// В этой функции-колбэк, в отличие от промиса, мы можем вызывать next сколько угодно раз.
// setTimeout(() => {
//   // Используем спец. метод у observer next(), в который мы передаем нужное значение, о котором сообщим подписчикам нашего Observable-объекта
//   observer.next('hello'); // в любом Observable-объекте нужно использовать этот метод next, он обязательный. Иначе Observable не будет ничего предоставлять наружу, т.е. не будет создавать никаких событий, и смысла в нем вообще тогда нет.
// }, 2000);

// Например сейчас мы уведомляем всех слушателей объекта строкой 'hello' через 2 секунды. Давайте сделаем еще так, чтобы мы делали уведомление через 3 сек.
// Получается, когда мы подписываемся на наш Observable, то через 2 сек после этого мы получим строку 'hello', а через 3 сек получим строку 'world'
// Т.е. после того, как мы подписались на Observable-объект, он существует в активном состоянии. Если внутри этого Observable-объекта в какой-то момент вызывается next(), то срабатывает колбэк для каждого нашего слушателя (сейчас только один слушатель в ngOnInit). Но слушателей может быть много, и они могут существовать в разных частях проекта. И каждый раз, когда в Observable сработал next, в каждом месте, где мы подписались на этот Observable, сработает функция-колбэк. В param придет то, что мы передаем в next()

// Добавим еще одного слушателя при клике на кнопку "Выбрать пиццу"
// Эти события независимы друг от друга. subscriber 1 - это один поток данных, а subscriber 2 - другой.
// Если мы обновим страницу и подождем, пока 3 сек, а только потом нажем кнопку, то эти два потока произойдут последовательно, потому что мы дождались выполнения одного подписчика, а затем нажали на кнопку, и случились другие операции (для второго подписчика)
// Но если мы обновим страницу и сразу же нажмем на кнопку, то у нас они пройдут параллельно (потому что эти операции не зависят друг от друга), и каждый подписчик существует самостоятельно и отдельно.

// Важный момент! Функция Observable не сработает, если мы не подпишемся ни разу на сам объект Observable. Observable в этом случае хотя и существует, но он неактивен.
// (observer) => {
//   setTimeout(() => {
//     observer.next('hello');
//   }, 2000);

// Observable может генерировать еще один тип сообщений для подписчиков - это ошибки.
// Если в Observable случилась ошибка, значит Observable завершается, и все слушатели перестают быть подписанными на него. Ошибка генерируется методом error у Obsrvable-объекта

// Принципиальный момент! наш Observable сейчас - это не один общий какой-то процесс, на который мы можем подписаться разными subscriber-ами.
// Процесс этот как раз и создается по подписке, несмотря на то, что мы работаем с одним Observable-объектом.
// Фукнция Observable будет выполняться для каждого нового наблюдателя отдельно.
// Если бы это был один процесс, то после завершения первого и нажатия на кнопку, мы бы уже не получили уведомлений, т.к. он в принципе завершился с ошибкой.
// Т.е. когда мы обновляем страницу, у нас запускается один Observable-объект для первого слушателя. Когда мы нажимаем на кнопку, для Observable-объекта запускается второй слушатель, и для него опять же срабатывает эта функция.

// Мы можем сделать так, чтобы наш Observable был одним процессом с общими уведомлениями для всех участников, и это был бы общий поток. Об этом - позже

// Обрабатывать сгенерированную ошибку мы можем точно так же, как обрабатывали ошибки у промиса, только у подписчика.
// Если нам нужно обрабатывать не только успешные ответы, но еще и ошибки, тогда нам нужно в subscribe передать не функцию-колбэк, а объект, который будет содержать 2 функции.
// 1 функция - next, 2 - error

// 3 вариант, который может случиться с Observable (помимо next() - успех, error() - ошибка), - это завершение через complete(). В момент вызова complete() она завершает Observable, и он в принципе перестает существовать (без ошибок, просто завершается).
// Даже если дальше что-то будет происходит, подписчики Observable не смогут получать от него уведомления, т.к. он уже убдет завершен.
// При этом если первый Observable завершился, и после этого мы нажмем на кнопку, то все повторится, т.к. по новой подписке создался новый процесс

// При этом в разных subscribe можно по-разному обрабатыать данные. Например в ngOnInit() subscribe будет содержать next и error, а в test() только next()

// Мы можем самостоятельно отписаться от Observable в конкретном месте (даже если он еще не завершился и не упал с ошибкой).
// Для этого у нашего this.observable.subscribe нужно использовать метод unsubscribe(), но при этом он должен там существовать

// Чтобы сделать отписку нашем Observable-объекте, надо в функции, которая служит для подписки на изменения Observable, вернуть объект, который будет содержать свойство unsubscribed

// У Observable-объектов есть различные операторы, которые можно использовать для промежуточной обработки данных. Они бывают 2 типов. Операторы по факту - это какие-то функции
// 1. Операторы создания Observable
// С их помощью можно создавать Observable-объекты без явного указания new Observable
// Их достаточно много, и все они используются для того, чтобы создать Observable на основе чего-то уже существующего
// Например мы можем сделать пример создания Observable на основе массива цифр
// ajax, bindCallback, bindNodeCallback, defer, empty, from fromEvent, fromEventPattern, generate, interval, of, range, throwError, timer, iif
// Актульаный список операторов лучше смотреть в документации RxJS (не angular) https://rxjs.dev/guide/operators#creation-operators-list

// 2. Операторы преобразования уже существующих Observable-объектов
// Они используются как пайпы для промежуточного преобразования Observable в другой Observable прям перед подпиской на изменения.
// Эти операторы не изменяют текущий Observable-объект, с которым мы работаем, а создают новый Observable в потоке с учетом тех изменений, которые мы делаем.
// И далее с этим новым Observable уже работает метод subscribe
// https://rxjs.dev/guide/operators#transformation-operators
// buffer, bufferCount, bufferTime, bufferToggle, bufferWhen, concatMap, concatMapTo, exhaust, exhaustMap, expand, groupBy, map, mapTo, mergeMap, mergeMapTo, mergeScan, pairwise, partition, pluck, scan, switchScan, switchMap, switchMapTo, window, windowCount, windowTime, windowToggle, windowWhen
// Попробуем самый часто используемый метод map. Метод map() применяет переданную функцию к какждому значению, которое отдается наблюдателям через next() и выдает результирующее значение через новый Observable
// Применяем изменения не там, где создаем Observable, а там, где подписываемся (для одного подписчика можем изменить его одним образом, а для другого - другим образом)

// Подход "Cold Observable"
// Разные потоки и состояния для каждого наблюдателя

// Подход "Hot Observable"
// Единое состояние и поток данных для всех наблюдателей
// Observable один для всех и регистрирует слушателей в один поток данных и вещает всем сразу
// Самый часто используемый способ (их много) применения Hot Observable - это создание спец. объекта Subject, который может как принимать значение, так и отдавать
// В Observable новые значения поступают только из колбэк-функции, а в Subject мы можем самостоятельно генерировать новое событие для наблюдателей вручную, используя функцию next(), а так же завершить поток функцией complete() или error().
//

// const subject = new Subject<number>();
// subject.subscribe({
//  next: (v) => console.log(`observerA: ${v}`);
// });
// subject.subscribe({
//  next: (v) => console.log(`observerB: ${v}`);
// });
// subject.next(1);
// subject.next(2);

// Подписку на subject также можно и нужно останавливать, так же, как и Observable

// Возможный подход к именованию объектов типа Observable
// Помечать их $ в конце названия переменной
