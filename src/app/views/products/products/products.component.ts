import { Component, OnDestroy, OnInit } from '@angular/core';
import { ProductType } from '../../../../types/product.type';
import { ProductService } from '../../../shared/services/product.service';
import { CartService } from 'src/app/shared/services/cart.service';
import { Router } from '@angular/router';
import { HttpClient } from '@angular/common/http';
import { catchError, map, of, retry, Subscription, tap } from 'rxjs';

@Component({
  selector: 'app-products',
  templateUrl: './products.component.html',
  styleUrls: ['./products.component.scss'],
})
export class ProductsComponent implements OnInit, OnDestroy {
  products: ProductType[] = [];
  private subscriptionProducts: Subscription | null = null;
  loading: boolean = false;

  constructor(
    private productService: ProductService,
    private cartService: CartService,
    private router: Router,
    private http: HttpClient
  ) {}

  ngOnInit(): void {
    // this.products = this.productService.getProducts();

    // получим данные о продуктах через запрос на бэкенд. сделаем спец утверждение типа для нашего запроса, что в результате нашего запросы мы получим определенный тип. Метод get можем использовать как дженерик метод и передать через <> тот тип, который мы получим в рез-те запроса. Тогда ниже IDE сама определяет, что в data будет массив ProductType. Важно понимать, что это лишь утверждение типа, и не факт, что бэкенд вернет именно такие данные в таком формате. Это лишь утверждение типа для компилятора
    // this.http.get<ProductType[]>('http://testologia.site/pizzas') // этой операцией мы сформировали запрос, но он еще не выполняется. возвращает Observable-объект.
    //   // чтобы осуществить запрос, необходимо вызвать функцию subscribe (подписываемся на изменения этого Observable-объекта). Функция-колбэк выполнится, когда мы получим какой-то ответ от сервера
    //   .subscribe((data) => { // можем присвоить data тип any, чтобы не было ошибок компиляции, но это не лучший подход. По-хорошему, мы должны указать тип data: ProductType[], потому что такой тип у this.products, а в него мы присваиваем data. Но мы этого сделать не можем, потому что у метода subscribe() есть четко определенные типы, которые могут возвращаться в этот объект params. Тогда здесь можем вообще не указывать тип, а сделать спец утверждение типа для нашего запроса
    //     this.products = data;
    //   })
    // По умолчанию любой Observable-объект из HttpClient имеет подход холодного потока.
    // Это значит, что сам запрос будет происходить каждый раз при подписке
    // Если мы продублируем, то этот запрос выполнится еще раз, потому что мы здесь заново подписались. Сам запрос осуществляется только при вызове метода subscribe() у этого Observable-объекта.
    // this.http.get<ProductType[]>('http://testologia.site/pizzas')
    //   .subscribe((data) => {
    //     this.products = data;
    //   })

    // сделаем запрос с параметром extraField=1, чтобы получить запрос в другом формате. В отличие от предыдущего варианта, здесь массив продуктов находятся в объекта по ключу data (а не просто массив продуктов)
    // this.http.get<{ data: ProductType[] }>('http://testologia1.site/pizzas?extraField=1') // Как это работает: мы осуществляем создание Observable-объекта, который в этот момент еще не выполняется, и привязываем к нему промежуточную обработку через pipe(). Далее вызываем фцнкцию subscribe(), и в этот момент уходит запрос. Когда мы получаем ответ по запросу, срабатывают операторры для обработки ответа (pipe() и map()). В result получаем исходный ответ сервера, через map() преобразовываем этот Observable к нужному виду, и в subscribe получаем уже преобразованный Observable.
    // для промежуточной обработки результата запроса используем оператор pipe()
    // .pipe(
    //   tap(result => { // Благодаря этому оператору мы можем выполнить любое побочное действие, т.е. этот оператор никак не изменяет наши данные и Observable. Он просто позвоялет что-то сделать. Т.е. это какая-то функция, которая вызовется для наших данных в рамках выполнения нашего запроса до того, как выполнится колбэк в subscribe().
    //     console.log(result);
    //   }),
    //   map(result => {// метод map() позволяет обработать каждый входящий рез-т из этого Observable (т.к. у нас только один запрос, соотв. обрабатывать мы будем только один этот рез-т)
    //     return result.data; // теперь мы, как и раньше, получаем массив продуктов. Сейчас тут ошибка из-за того, что тот формат, который мы утвердили get<ProductType[]>, не соответствует тому, что мы используем
    //   }),
    // catchError(error => { // catchError() позволяет либо выбросить свою ошибку, либо создать новый Observable, с которым дальше уже будет работать функция next(). Т.е. если здесь мы вернем не ошибку, которая приведет к error(), а новый Observable, то он заменится в текущем формате и передастся далее в next()
    //   throw new Error('omg'); // сгенерируем свою кастомную ошибку, допустим для нас это важно. Пока что используем стандартный класс Error, но в больших проектах часто используют какой-то кастомный класс Error, который расширяет стандартный класс Error, в который передают какие-то доп. параметры. В консоли выводится наша ошибка Error: omg. Но при этом ы все равно попадаем в секцию subscribe() и выполняем не next(), а error(). Т.е. ошибка в люом случае произошла, просто мы ее отловили на промежуточном этапе и выбросили свою вместо той, которая произошла по умолчанию. Эта функция сработает (и функция-колбэк) ТОЛЬКО если Observable будет завершаться с ошибкой.
    // })
    // catchError(error => {
    //   return of([]); // генерируем новый Observable (т.е. возвращаем его) с помощью оператора of(), передавая туда пустой массив.
    // }),
    // retry(3) // Если наш запрос был неуспешным, с помощью оператора retry(), можем повторить его несколько раз. В скобках указываем, какое кол-во раз нужно повторить запрос в случае ошибки. Если в url ошибка и нет catchError(), то запрос будет выполенен 4 раза. Мы выполнили запрос и определили, что там есть ошибка. В это время сработал оператор retry() и повторил этот зарпос еще 3 раза. После этого мы все равно насткнулись на ошибку и попали в секцию error() и перешли на главную
    // Можно добавить сколько угодно операторов для осуществления каких-то действий и промежуточной обработки.
    // )
    // .subscribe({
    //   next: (data) => {
    //     this.products = data;
    //     console.log('next');
    //   },
    //   В нашем Observable по-хорошему нужно сделать проверку на возникновение ошибок. Например, если в запросе получили ошибку, то будем переводить пользователя на главную.
    // error: (error) => {
    //   console.log(error); // получаем ошибку в HttpErrorResponse
    //   this.router.navigate(['/']); // переводим юзера на главную
    // }
    // })

    // теперь запрос в сервисе, а тут только подписываемся.
    this.loading = true;
    this.subscriptionProducts = this.productService
      .getProducts()
      .pipe(
        tap(() => {
          this.loading = false; // чтобы не дублировать, вынесли в pipe() tap()
        })
      )
      .subscribe({
        next: (data) => {
          // this.loading = false; // чтобы не дублировать, вынесли в pipe() tap()
          this.products = data;
          console.log('next');
        },
        error: (error) => {
          // this.loading = false;
          console.log(error); // получаем ошибку в HttpErrorResponse
          this.router.navigate(['/']); // переводим юзера на главную
        },
      });
  }

  ngOnDestroy(): void {
    this.subscriptionProducts?.unsubscribe();
  }

  addToCart(title: string): void {
    this.cartService.product = title; // сохраняем значение (название товара) в переменную product объекта cartService
    // Теперь нужно перевести пользователя на страницу заказа, но не из шаблона по ссылке, а здесь, из кода в компоненте.
    // Для этого нам нужно заинжектить еще один класс - сущность роутера
    // this.router.navigate(['/order']);

    // url-параметры
    // this.router.navigate(['/order', {product: title}]); // передадим вторым элементом массива - первого параметра метода navigate(). Получим http://localhost:4200/order;product=МЯСНАЯ%20ДЕЛЮКС не являются правильным форматом для query-параметров URL-адреса. Поэтому лучше использовать правильные query-параметры

    // url query-параметры
    this.router.navigate(['/order'], { queryParams: { product: title } }); // передадим вторым параметром метода navigate() NavigationExtras. Получим http://localhost:4200/order?product=ПЕПРЕРОНИ%20ДАБЛ - теперь добавились стандартные url query-параметры через знак ?
    // теперь нам здесь на странице order нужно получить этот параметр, чтобы подставить в поле заказа и не использовать сервис.
    // Варианты работы с текущим URL и параметрами
    // 1. Использовать роутер и специальный объект типа Observable у queryParams, в котором надо будет использовать подписку на эту событийную модель. С объектами типа Observable мы познакомимся чуть позже.
    // 2. Используя snapshot (снимок состояния). Для этого мы будем использовать уже другой объект, но там мы сможем получить только конечное состояния URL-строки. Если она вдруг изменится во время жизни компонента, но мы не сможем это отследить.
  }
}

// URL-параметры
// Сделаем так, чтобы при нажатии на кнопку "В корзину", название товара добавлять в URL-адрес к странице order, а на странице order мы могли получить этот параметр и вставить его в поле продукта.

// URL-параметры могут быть 2 типов:
// 1. Query-параметры
// 2. Параметры, являющиеся частями основной URL-строки, которые содержатся в сегментах адреса.
